/* Kronos Compute - High-performance compute-only Vulkan implementation */


#ifndef KRONOS_COMPUTE_H
#define KRONOS_COMPUTE_H

/* Warning: this file is autogenerated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>
#include <stdint.h>
#include <stddef.h>

/**
 * Version information
 */
#define KRONOS_VERSION_MAJOR 0

#define KRONOS_VERSION_MINOR 2

#define KRONOS_VERSION_PATCH 3

#define VK_QUEUE_FAMILY_IGNORED ~0

#define VK_MAX_PHYSICAL_DEVICE_NAME_SIZE 256

#define VK_UUID_SIZE 16

#define VK_MAX_MEMORY_HEAPS 16

#define VK_MAX_MEMORY_TYPES 32

#define VK_API_VERSION_1_0 (((1 << 22) | (0 << 12)) | 0)

#define VK_API_VERSION_1_1 (((1 << 22) | (1 << 12)) | 0)

#define VK_API_VERSION_1_2 (((1 << 22) | (2 << 12)) | 0)

#define VK_API_VERSION_1_3 (((1 << 22) | (3 << 12)) | 0)

#define VK_ERROR_OUT_OF_POOL_MEMORY -1000069000

/**
 * Maximum push constant size (typical hardware limit)
 */
#define MAX_PUSH_CONSTANT_SIZE 128

/**
 * Descriptor set 0 is reserved for persistent storage buffers
 */
#define PERSISTENT_DESCRIPTOR_SET 0

/**
 * Command buffer level
 */
enum VkCommandBufferLevel {
  Primary = 0,
  Secondary = 1,
};
typedef int32_t VkCommandBufferLevel;

/**
 * Descriptor type (compute-relevant only)
 */
enum VkDescriptorType {
  Sampler = 0,
  SampledImage = 2,
  StorageImage = 3,
  UniformBuffer = 6,
  StorageBuffer = 7,
  UniformBufferDynamic = 8,
  StorageBufferDynamic = 9,
};
typedef int32_t VkDescriptorType;

enum VkImageLayout {
  Undefined = 0,
  General = 1,
  TransferSrcOptimal = 6,
  TransferDstOptimal = 7,
};
typedef int32_t VkImageLayout;

enum VkInternalAllocationType {
  Executable = 0,
};
typedef int32_t VkInternalAllocationType;

/**
 * Physical device type
 */
enum VkPhysicalDeviceType {
  Other = 0,
  IntegratedGpu = 1,
  DiscreteGpu = 2,
  VirtualGpu = 3,
  Cpu = 4,
};
typedef int32_t VkPhysicalDeviceType;

/**
 * Pipeline bind point
 */
enum VkPipelineBindPoint {
  Compute = 1,
};
typedef int32_t VkPipelineBindPoint;

/**
 * Result codes for Kronos API operations
 */
enum VkResult {
  Success = 0,
  NotReady = 1,
  Timeout = 2,
  EventSet = 3,
  EventReset = 4,
  Incomplete = 5,
  ErrorOutOfHostMemory = -1,
  ErrorOutOfDeviceMemory = -2,
  ErrorInitializationFailed = -3,
  ErrorDeviceLost = -4,
  ErrorMemoryMapFailed = -5,
  ErrorLayerNotPresent = -6,
  ErrorExtensionNotPresent = -7,
  ErrorFeatureNotPresent = -8,
  ErrorIncompatibleDriver = -9,
  ErrorTooManyObjects = -10,
  ErrorFormatNotSupported = -11,
  ErrorFragmentedPool = -12,
  ErrorUnknown = -13,
  ErrorOutOfPoolMemory = VK_ERROR_OUT_OF_POOL_MEMORY,
};
typedef int32_t VkResult;

/**
 * Shader stage flags
 */
enum VkShaderStageFlagBits {
  Compute = 32,
};
typedef uint32_t VkShaderStageFlagBits;

/**
 * Sharing mode
 */
enum VkSharingMode {
  Exclusive = 0,
  Concurrent = 1,
};
typedef int32_t VkSharingMode;

/**
 * Structure type identifiers
 */
enum VkStructureType {
  ApplicationInfo = 0,
  InstanceCreateInfo = 1,
  DeviceQueueCreateInfo = 2,
  DeviceCreateInfo = 3,
  SubmitInfo = 4,
  MemoryAllocateInfo = 5,
  MappedMemoryRange = 6,
  FenceCreateInfo = 8,
  SemaphoreCreateInfo = 9,
  EventCreateInfo = 10,
  QueryPoolCreateInfo = 11,
  BufferCreateInfo = 12,
  PipelineShaderStageCreateInfo = 18,
  ComputePipelineCreateInfo = 29,
  PipelineLayoutCreateInfo = 30,
  DescriptorSetLayoutCreateInfo = 32,
  DescriptorPoolCreateInfo = 33,
  DescriptorSetAllocateInfo = 34,
  WriteDescriptorSet = 35,
  CopyDescriptorSet = 36,
  ShaderModuleCreateInfo = 38,
  CommandPoolCreateInfo = 39,
  CommandBufferAllocateInfo = 40,
  CommandBufferBeginInfo = 42,
  BufferMemoryBarrier = 44,
  MemoryBarrier = 46,
  PipelineCacheCreateInfo = 47,
  SemaphoreTypeCreateInfo = 1000207002,
  TimelineSemaphoreSubmitInfo = 1000207003,
  SemaphoreWaitInfo = 1000207004,
};
typedef int32_t VkStructureType;

enum VkSystemAllocationScope {
  Command = 0,
  Object = 1,
  Cache = 2,
  Device = 3,
  Instance = 4,
};
typedef int32_t VkSystemAllocationScope;

typedef uint32_t VkFlags;

typedef VkFlags VkInstanceCreateFlags;
typedef VkFlags VkQueueFlags;
typedef VkFlags VkMemoryPropertyFlags;
typedef VkFlags VkMemoryHeapFlags;
typedef VkFlags VkBufferUsageFlags;
typedef VkFlags VkBufferCreateFlags;
typedef VkFlags VkShaderStageFlags;
typedef VkFlags VkPipelineStageFlags;
typedef VkFlags VkPipelineCreateFlags;
typedef VkFlags VkPipelineShaderStageCreateFlags;
typedef VkFlags VkCommandPoolCreateFlags;
typedef VkFlags VkCommandBufferUsageFlags;
typedef VkFlags VkAccessFlags;
typedef VkFlags VkDependencyFlags;
typedef VkFlags VkDescriptorPoolCreateFlags;
typedef VkFlags VkDescriptorPoolResetFlags;
typedef VkFlags VkFenceCreateFlags;

/**
 * Helper for null-terminated string pointers
 */
typedef const char *PtrCStr;

/**
 * Application information
 */
typedef struct VkApplicationInfo {
  VkStructureType sType;
  const void *pNext;
  PtrCStr pApplicationName;
  uint32_t applicationVersion;
  PtrCStr pEngineName;
  uint32_t engineVersion;
  uint32_t apiVersion;
} VkApplicationInfo;

/**
 * Instance creation information
 */
typedef struct VkInstanceCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkInstanceCreateFlags flags;
  const struct VkApplicationInfo *pApplicationInfo;
  uint32_t enabledLayerCount;
  const PtrCStr *ppEnabledLayerNames;
  uint32_t enabledExtensionCount;
  const PtrCStr *ppEnabledExtensionNames;
} VkInstanceCreateInfo;

/**
 * Allocation callbacks (optional)
 */
typedef struct VkAllocationCallbacks {
  void *pUserData;
  void *(*pfnAllocation)(void*, uintptr_t, uintptr_t, VkSystemAllocationScope);
  void *(*pfnReallocation)(void*, void*, uintptr_t, uintptr_t, VkSystemAllocationScope);
  void (*pfnFree)(void*, void*);
  void (*pfnInternalAllocation)(void*, uintptr_t, VkInternalAllocationType, VkSystemAllocationScope);
  void (*pfnInternalFree)(void*, uintptr_t, VkInternalAllocationType, VkSystemAllocationScope);
} VkAllocationCallbacks;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_InstanceT;

typedef Handle_InstanceT VkInstance;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_PhysicalDeviceT;

typedef Handle_PhysicalDeviceT VkPhysicalDevice;

/**
 * Physical device limits (simplified for compute)
 */
typedef struct VkPhysicalDeviceLimits {
  uint32_t maxComputeSharedMemorySize;
  uint32_t maxComputeWorkGroupCount[3];
  uint32_t maxComputeWorkGroupInvocations;
  uint32_t maxComputeWorkGroupSize[3];
} VkPhysicalDeviceLimits;

typedef uint32_t VkBool32;

/**
 * Physical device sparse properties
 */
typedef struct VkPhysicalDeviceSparseProperties {
  VkBool32 residencyStandard2DBlockShape;
  VkBool32 residencyStandard2DMultisampleBlockShape;
  VkBool32 residencyStandard3DBlockShape;
  VkBool32 residencyAlignedMipSize;
  VkBool32 residencyNonResidentStrict;
} VkPhysicalDeviceSparseProperties;

/**
 * Physical device properties
 */
typedef struct VkPhysicalDeviceProperties {
  uint32_t apiVersion;
  uint32_t driverVersion;
  uint32_t vendorID;
  uint32_t deviceID;
  VkPhysicalDeviceType deviceType;
  char deviceName[VK_MAX_PHYSICAL_DEVICE_NAME_SIZE];
  uint8_t pipelineCacheUUID[VK_UUID_SIZE];
  struct VkPhysicalDeviceLimits limits;
  struct VkPhysicalDeviceSparseProperties sparseProperties;
} VkPhysicalDeviceProperties;

/**
 * Memory type
 */
typedef struct VkMemoryType {
  VkMemoryPropertyFlags propertyFlags;
  uint32_t heapIndex;
} VkMemoryType;

typedef uint64_t VkDeviceSize;

/**
 * Memory heap
 */
typedef struct VkMemoryHeap {
  VkDeviceSize size;
  VkFlags flags;
} VkMemoryHeap;

/**
 * Physical device memory properties
 */
typedef struct VkPhysicalDeviceMemoryProperties {
  uint32_t memoryTypeCount;
  struct VkMemoryType memoryTypes[VK_MAX_MEMORY_TYPES];
  uint32_t memoryHeapCount;
  struct VkMemoryHeap memoryHeaps[VK_MAX_MEMORY_HEAPS];
} VkPhysicalDeviceMemoryProperties;

/**
 * 3D extent
 */
typedef struct VkExtent3D {
  uint32_t width;
  uint32_t height;
  uint32_t depth;
} VkExtent3D;

/**
 * Queue family properties
 */
typedef struct VkQueueFamilyProperties {
  VkQueueFlags queueFlags;
  uint32_t queueCount;
  uint32_t timestampValidBits;
  struct VkExtent3D minImageTransferGranularity;
} VkQueueFamilyProperties;

typedef VkFlags VkDeviceCreateFlags;

typedef VkFlags VkDeviceQueueCreateFlags;

/**
 * Device queue creation info
 */
typedef struct VkDeviceQueueCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDeviceQueueCreateFlags flags;
  uint32_t queueFamilyIndex;
  uint32_t queueCount;
  const float *pQueuePriorities;
} VkDeviceQueueCreateInfo;

/**
 * Physical device features (compute-relevant only)
 */
typedef struct VkPhysicalDeviceFeatures {
  VkBool32 robustBufferAccess;
  VkBool32 shaderFloat64;
  VkBool32 shaderInt64;
  VkBool32 shaderInt16;
  VkBool32 shaderStorageBufferArrayDynamicIndexing;
  VkBool32 shaderStorageImageArrayDynamicIndexing;
  VkBool32 shaderStorageImageReadWithoutFormat;
  VkBool32 shaderStorageImageWriteWithoutFormat;
} VkPhysicalDeviceFeatures;

/**
 * Device creation info
 */
typedef struct VkDeviceCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDeviceCreateFlags flags;
  uint32_t queueCreateInfoCount;
  const struct VkDeviceQueueCreateInfo *pQueueCreateInfos;
  uint32_t enabledLayerCount;
  const PtrCStr *ppEnabledLayerNames;
  uint32_t enabledExtensionCount;
  const PtrCStr *ppEnabledExtensionNames;
  const struct VkPhysicalDeviceFeatures *pEnabledFeatures;
} VkDeviceCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_DeviceT;

typedef Handle_DeviceT VkDevice;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_QueueT;

typedef Handle_QueueT VkQueue;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_SemaphoreT;

typedef Handle_SemaphoreT VkSemaphore;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_CommandBufferT;

typedef Handle_CommandBufferT VkCommandBuffer;

/**
 * Submit info
 */
typedef struct VkSubmitInfo {
  VkStructureType sType;
  const void *pNext;
  uint32_t waitSemaphoreCount;
  const VkSemaphore *pWaitSemaphores;
  const VkPipelineStageFlags *pWaitDstStageMask;
  uint32_t commandBufferCount;
  const VkCommandBuffer *pCommandBuffers;
  uint32_t signalSemaphoreCount;
  const VkSemaphore *pSignalSemaphores;
} VkSubmitInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_FenceT;

typedef Handle_FenceT VkFence;

/**
 * Memory allocate info
 */
typedef struct VkMemoryAllocateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDeviceSize allocationSize;
  uint32_t memoryTypeIndex;
} VkMemoryAllocateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_DeviceMemoryT;

typedef Handle_DeviceMemoryT VkDeviceMemory;

typedef VkFlags VkMemoryMapFlags;

/**
 * Buffer creation info (optimized packing)
 */
typedef struct VkBufferCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDeviceSize size;
  VkBufferUsageFlags usage;
  VkSharingMode sharingMode;
  uint32_t queueFamilyIndexCount;
  const uint32_t *pQueueFamilyIndices;
  VkBufferCreateFlags flags;
} VkBufferCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_BufferT;

typedef Handle_BufferT VkBuffer;

/**
 * Memory requirements
 */
typedef struct VkMemoryRequirements {
  VkDeviceSize size;
  VkDeviceSize alignment;
  uint32_t memoryTypeBits;
} VkMemoryRequirements;

/**
 * Shader module creation info
 */
typedef struct VkShaderModuleCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkFlags flags;
  uintptr_t codeSize;
  const uint32_t *pCode;
} VkShaderModuleCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_ShaderModuleT;

typedef Handle_ShaderModuleT VkShaderModule;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_PipelineCacheT;

typedef Handle_PipelineCacheT VkPipelineCache;

/**
 * Specialization map entry
 */
typedef struct VkSpecializationMapEntry {
  uint32_t constantID;
  uint32_t offset;
  uintptr_t size;
} VkSpecializationMapEntry;

/**
 * Specialization info
 */
typedef struct VkSpecializationInfo {
  uint32_t mapEntryCount;
  const struct VkSpecializationMapEntry *pMapEntries;
  uintptr_t dataSize;
  const void *pData;
} VkSpecializationInfo;

/**
 * Pipeline shader stage creation info
 */
typedef struct VkPipelineShaderStageCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkPipelineShaderStageCreateFlags flags;
  VkShaderStageFlagBits stage;
  VkShaderModule module;
  const int8_t *pName;
  const struct VkSpecializationInfo *pSpecializationInfo;
} VkPipelineShaderStageCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_PipelineLayoutT;

typedef Handle_PipelineLayoutT VkPipelineLayout;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_PipelineT;

typedef Handle_PipelineT VkPipeline;

/**
 * Compute pipeline creation info (optimized)
 */
typedef struct VkComputePipelineCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkPipelineCreateFlags flags;
  struct VkPipelineShaderStageCreateInfo stage;
  VkPipelineLayout layout;
  VkPipeline basePipelineHandle;
  int32_t basePipelineIndex;
} VkComputePipelineCreateInfo;

typedef VkFlags VkPipelineLayoutCreateFlags;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_DescriptorSetLayoutT;

typedef Handle_DescriptorSetLayoutT VkDescriptorSetLayout;

/**
 * Push constant range
 */
typedef struct VkPushConstantRange {
  VkShaderStageFlags stageFlags;
  uint32_t offset;
  uint32_t size;
} VkPushConstantRange;

/**
 * Pipeline layout creation info
 */
typedef struct VkPipelineLayoutCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkPipelineLayoutCreateFlags flags;
  uint32_t setLayoutCount;
  const VkDescriptorSetLayout *pSetLayouts;
  uint32_t pushConstantRangeCount;
  const struct VkPushConstantRange *pPushConstantRanges;
} VkPipelineLayoutCreateInfo;

/**
 * Command pool creation info
 */
typedef struct VkCommandPoolCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkCommandPoolCreateFlags flags;
  uint32_t queueFamilyIndex;
} VkCommandPoolCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_CommandPoolT;

typedef Handle_CommandPoolT VkCommandPool;

/**
 * Command buffer allocate info
 */
typedef struct VkCommandBufferAllocateInfo {
  VkStructureType sType;
  const void *pNext;
  VkCommandPool commandPool;
  VkCommandBufferLevel level;
  uint32_t commandBufferCount;
} VkCommandBufferAllocateInfo;

/**
 * Command buffer begin info
 */
typedef struct VkCommandBufferBeginInfo {
  VkStructureType sType;
  const void *pNext;
  VkCommandBufferUsageFlags flags;
  const void *pInheritanceInfo;
} VkCommandBufferBeginInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_DescriptorSetT;

typedef Handle_DescriptorSetT VkDescriptorSet;

/**
 * Memory barrier
 */
typedef struct VkMemoryBarrier {
  VkStructureType sType;
  const void *pNext;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
} VkMemoryBarrier;

/**
 * Buffer memory barrier
 */
typedef struct VkBufferMemoryBarrier {
  VkStructureType sType;
  const void *pNext;
  VkAccessFlags srcAccessMask;
  VkAccessFlags dstAccessMask;
  uint32_t srcQueueFamilyIndex;
  uint32_t dstQueueFamilyIndex;
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize size;
} VkBufferMemoryBarrier;

/**
 * Buffer copy region
 */
typedef struct VkBufferCopy {
  VkDeviceSize srcOffset;
  VkDeviceSize dstOffset;
  VkDeviceSize size;
} VkBufferCopy;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_EventT;

typedef Handle_EventT VkEvent;

typedef VkFlags VkDescriptorSetLayoutCreateFlags;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_SamplerT;

typedef Handle_SamplerT VkSampler;

/**
 * Descriptor set layout binding
 */
typedef struct VkDescriptorSetLayoutBinding {
  uint32_t binding;
  VkDescriptorType descriptorType;
  uint32_t descriptorCount;
  VkShaderStageFlags stageFlags;
  const VkSampler *pImmutableSamplers;
} VkDescriptorSetLayoutBinding;

/**
 * Descriptor set layout creation info
 */
typedef struct VkDescriptorSetLayoutCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDescriptorSetLayoutCreateFlags flags;
  uint32_t bindingCount;
  const struct VkDescriptorSetLayoutBinding *pBindings;
} VkDescriptorSetLayoutCreateInfo;

/**
 * Descriptor pool size
 */
typedef struct VkDescriptorPoolSize {
  VkDescriptorType type_;
  uint32_t descriptorCount;
} VkDescriptorPoolSize;

/**
 * Descriptor pool creation info
 */
typedef struct VkDescriptorPoolCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDescriptorPoolCreateFlags flags;
  uint32_t maxSets;
  uint32_t poolSizeCount;
  const struct VkDescriptorPoolSize *pPoolSizes;
} VkDescriptorPoolCreateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_DescriptorPoolT;

typedef Handle_DescriptorPoolT VkDescriptorPool;

/**
 * Descriptor set allocate info
 */
typedef struct VkDescriptorSetAllocateInfo {
  VkStructureType sType;
  const void *pNext;
  VkDescriptorPool descriptorPool;
  uint32_t descriptorSetCount;
  const VkDescriptorSetLayout *pSetLayouts;
} VkDescriptorSetAllocateInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_ImageViewT;

typedef Handle_ImageViewT VkImageView;

/**
 * Descriptor image info
 */
typedef struct VkDescriptorImageInfo {
  VkSampler sampler;
  VkImageView imageView;
  VkImageLayout imageLayout;
} VkDescriptorImageInfo;

/**
 * Descriptor buffer info
 */
typedef struct VkDescriptorBufferInfo {
  VkBuffer buffer;
  VkDeviceSize offset;
  VkDeviceSize range;
} VkDescriptorBufferInfo;

/**
 * Opaque handle type with phantom data for type safety
 */
typedef uint64_t Handle_BufferViewT;

typedef Handle_BufferViewT VkBufferView;

/**
 * Write descriptor set
 */
typedef struct VkWriteDescriptorSet {
  VkStructureType sType;
  const void *pNext;
  VkDescriptorSet dstSet;
  uint32_t dstBinding;
  uint32_t dstArrayElement;
  uint32_t descriptorCount;
  VkDescriptorType descriptorType;
  const struct VkDescriptorImageInfo *pImageInfo;
  const struct VkDescriptorBufferInfo *pBufferInfo;
  const VkBufferView *pTexelBufferView;
} VkWriteDescriptorSet;

/**
 * Copy descriptor set
 */
typedef struct VkCopyDescriptorSet {
  VkStructureType sType;
  const void *pNext;
  VkDescriptorSet srcSet;
  uint32_t srcBinding;
  uint32_t srcArrayElement;
  VkDescriptorSet dstSet;
  uint32_t dstBinding;
  uint32_t dstArrayElement;
  uint32_t descriptorCount;
} VkCopyDescriptorSet;

/**
 * Fence creation info
 */
typedef struct VkFenceCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkFenceCreateFlags flags;
} VkFenceCreateInfo;

/**
 * Semaphore creation info
 */
typedef struct VkSemaphoreCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkFlags flags;
} VkSemaphoreCreateInfo;

/**
 * Event creation info
 */
typedef struct VkEventCreateInfo {
  VkStructureType sType;
  const void *pNext;
  VkFlags flags;
} VkEventCreateInfo;



#define VK_TRUE 1

#define VK_FALSE 0

#define VK_WHOLE_SIZE ~0

/**
 * Create a Kronos instance
 */
VkResult vkCreateInstance(const struct VkInstanceCreateInfo *pCreateInfo,
                          const struct VkAllocationCallbacks *pAllocator,
                          VkInstance *pInstance);

/**
 * Destroy instance
 */
void vkDestroyInstance(VkInstance instance, const struct VkAllocationCallbacks *pAllocator);

/**
 * Enumerate physical devices (GPUs)
 */
VkResult vkEnumeratePhysicalDevices(VkInstance instance,
                                    uint32_t *pPhysicalDeviceCount,
                                    VkPhysicalDevice *pPhysicalDevices);

/**
 * Get physical device properties
 */
void vkGetPhysicalDeviceProperties(VkPhysicalDevice physicalDevice,
                                   struct VkPhysicalDeviceProperties *pProperties);

/**
 * Get physical device memory properties
 */
void vkGetPhysicalDeviceMemoryProperties(VkPhysicalDevice physicalDevice,
                                         struct VkPhysicalDeviceMemoryProperties *pMemoryProperties);

/**
 * Get physical device queue family properties
 */
void vkGetPhysicalDeviceQueueFamilyProperties(VkPhysicalDevice physicalDevice,
                                              uint32_t *pQueueFamilyPropertyCount,
                                              struct VkQueueFamilyProperties *pQueueFamilyProperties);

/**
 * Create a logical device
 */
VkResult vkCreateDevice(VkPhysicalDevice physicalDevice,
                        const struct VkDeviceCreateInfo *pCreateInfo,
                        const struct VkAllocationCallbacks *pAllocator,
                        VkDevice *pDevice);

/**
 * Destroy a logical device
 */
void vkDestroyDevice(VkDevice device, const struct VkAllocationCallbacks *pAllocator);

/**
 * Get a device queue
 */
void vkGetDeviceQueue(VkDevice device,
                      uint32_t queueFamilyIndex,
                      uint32_t queueIndex,
                      VkQueue *pQueue);

/**
 * Submit work to a queue
 */
VkResult vkQueueSubmit(VkQueue queue,
                       uint32_t submitCount,
                       const struct VkSubmitInfo *pSubmits,
                       VkFence fence);

/**
 * Wait for queue to become idle
 */
VkResult vkQueueWaitIdle(VkQueue queue);

/**
 * Wait for device to become idle
 */
VkResult vkDeviceWaitIdle(VkDevice device);

/**
 * Allocate device memory
 */
VkResult vkAllocateMemory(VkDevice device,
                          const struct VkMemoryAllocateInfo *pAllocateInfo,
                          const struct VkAllocationCallbacks *pAllocator,
                          VkDeviceMemory *pMemory);

/**
 * Free device memory
 */
void vkFreeMemory(VkDevice device,
                  VkDeviceMemory memory,
                  const struct VkAllocationCallbacks *pAllocator);

/**
 * Map memory for CPU access
 */
VkResult vkMapMemory(VkDevice device,
                     VkDeviceMemory memory,
                     VkDeviceSize offset,
                     VkDeviceSize size,
                     VkMemoryMapFlags flags,
                     void **ppData);

/**
 * Unmap memory
 */
void vkUnmapMemory(VkDevice device, VkDeviceMemory memory);

/**
 * Create a buffer
 */
VkResult vkCreateBuffer(VkDevice device,
                        const struct VkBufferCreateInfo *pCreateInfo,
                        const struct VkAllocationCallbacks *pAllocator,
                        VkBuffer *pBuffer);

/**
 * Destroy a buffer
 */
void vkDestroyBuffer(VkDevice device,
                     VkBuffer buffer,
                     const struct VkAllocationCallbacks *pAllocator);

/**
 * Get buffer memory requirements
 */
void vkGetBufferMemoryRequirements(VkDevice device,
                                   VkBuffer buffer,
                                   struct VkMemoryRequirements *pMemoryRequirements);

/**
 * Bind buffer to memory
 */
VkResult vkBindBufferMemory(VkDevice device,
                            VkBuffer buffer,
                            VkDeviceMemory memory,
                            VkDeviceSize memoryOffset);

/**
 * Create shader module
 */
VkResult vkCreateShaderModule(VkDevice device,
                              const struct VkShaderModuleCreateInfo *pCreateInfo,
                              const struct VkAllocationCallbacks *pAllocator,
                              VkShaderModule *pShaderModule);

/**
 * Destroy shader module
 */
void vkDestroyShaderModule(VkDevice device,
                           VkShaderModule shaderModule,
                           const struct VkAllocationCallbacks *pAllocator);

/**
 * Create compute pipelines
 */
VkResult vkCreateComputePipelines(VkDevice device,
                                  VkPipelineCache pipelineCache,
                                  uint32_t createInfoCount,
                                  const struct VkComputePipelineCreateInfo *pCreateInfos,
                                  const struct VkAllocationCallbacks *pAllocator,
                                  VkPipeline *pPipelines);

/**
 * Destroy pipeline
 */
void vkDestroyPipeline(VkDevice device,
                       VkPipeline pipeline,
                       const struct VkAllocationCallbacks *pAllocator);

/**
 * Create pipeline layout
 */
VkResult vkCreatePipelineLayout(VkDevice device,
                                const struct VkPipelineLayoutCreateInfo *pCreateInfo,
                                const struct VkAllocationCallbacks *pAllocator,
                                VkPipelineLayout *pPipelineLayout);

/**
 * Destroy pipeline layout
 */
void vkDestroyPipelineLayout(VkDevice device,
                             VkPipelineLayout pipelineLayout,
                             const struct VkAllocationCallbacks *pAllocator);

/**
 * Create command pool
 */
VkResult vkCreateCommandPool(VkDevice device,
                             const struct VkCommandPoolCreateInfo *pCreateInfo,
                             const struct VkAllocationCallbacks *pAllocator,
                             VkCommandPool *pCommandPool);

/**
 * Destroy command pool
 */
void vkDestroyCommandPool(VkDevice device,
                          VkCommandPool commandPool,
                          const struct VkAllocationCallbacks *pAllocator);

/**
 * Allocate command buffers
 */
VkResult vkAllocateCommandBuffers(VkDevice device,
                                  const struct VkCommandBufferAllocateInfo *pAllocateInfo,
                                  VkCommandBuffer *pCommandBuffers);

/**
 * Free command buffers
 */
void vkFreeCommandBuffers(VkDevice device,
                          VkCommandPool commandPool,
                          uint32_t commandBufferCount,
                          const VkCommandBuffer *pCommandBuffers);

/**
 * Begin command buffer recording
 */
VkResult vkBeginCommandBuffer(VkCommandBuffer commandBuffer,
                              const struct VkCommandBufferBeginInfo *pBeginInfo);

/**
 * End command buffer recording
 */
VkResult vkEndCommandBuffer(VkCommandBuffer commandBuffer);

/**
 * Bind pipeline
 */
void vkCmdBindPipeline(VkCommandBuffer commandBuffer,
                       VkPipelineBindPoint pipelineBindPoint,
                       VkPipeline pipeline);

/**
 * Bind descriptor sets
 */
void vkCmdBindDescriptorSets(VkCommandBuffer commandBuffer,
                             VkPipelineBindPoint pipelineBindPoint,
                             VkPipelineLayout layout,
                             uint32_t firstSet,
                             uint32_t descriptorSetCount,
                             const VkDescriptorSet *pDescriptorSets,
                             uint32_t dynamicOffsetCount,
                             const uint32_t *pDynamicOffsets);

/**
 * Push constants
 */
void vkCmdPushConstants(VkCommandBuffer commandBuffer,
                        VkPipelineLayout layout,
                        VkShaderStageFlags stageFlags,
                        uint32_t offset,
                        uint32_t size,
                        const void *pValues);

/**
 * Dispatch compute work
 */
void vkCmdDispatch(VkCommandBuffer commandBuffer,
                   uint32_t groupCountX,
                   uint32_t groupCountY,
                   uint32_t groupCountZ);

/**
 * Dispatch compute work with indirect buffer
 */
void vkCmdDispatchIndirect(VkCommandBuffer commandBuffer, VkBuffer buffer, VkDeviceSize offset);

/**
 * Pipeline barrier
 */
void vkCmdPipelineBarrier(VkCommandBuffer commandBuffer,
                          VkPipelineStageFlags srcStageMask,
                          VkPipelineStageFlags dstStageMask,
                          VkDependencyFlags dependencyFlags,
                          uint32_t memoryBarrierCount,
                          const struct VkMemoryBarrier *pMemoryBarriers,
                          uint32_t bufferMemoryBarrierCount,
                          const struct VkBufferMemoryBarrier *pBufferMemoryBarriers,
                          uint32_t imageMemoryBarrierCount,
                          const void *pImageMemoryBarriers);

/**
 * Copy buffer
 */
void vkCmdCopyBuffer(VkCommandBuffer commandBuffer,
                     VkBuffer srcBuffer,
                     VkBuffer dstBuffer,
                     uint32_t regionCount,
                     const struct VkBufferCopy *pRegions);

/**
 * Set event
 */
void vkCmdSetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);

/**
 * Reset event
 */
void vkCmdResetEvent(VkCommandBuffer commandBuffer, VkEvent event, VkPipelineStageFlags stageMask);

/**
 * Wait for events
 */
void vkCmdWaitEvents(VkCommandBuffer commandBuffer,
                     uint32_t eventCount,
                     const VkEvent *pEvents,
                     VkPipelineStageFlags srcStageMask,
                     VkPipelineStageFlags dstStageMask,
                     uint32_t memoryBarrierCount,
                     const struct VkMemoryBarrier *pMemoryBarriers,
                     uint32_t bufferMemoryBarrierCount,
                     const struct VkBufferMemoryBarrier *pBufferMemoryBarriers,
                     uint32_t imageMemoryBarrierCount,
                     const void *pImageMemoryBarriers);

/**
 * Create descriptor set layout
 */
VkResult vkCreateDescriptorSetLayout(VkDevice device,
                                     const struct VkDescriptorSetLayoutCreateInfo *pCreateInfo,
                                     const struct VkAllocationCallbacks *pAllocator,
                                     VkDescriptorSetLayout *pSetLayout);

/**
 * Destroy descriptor set layout
 */
void vkDestroyDescriptorSetLayout(VkDevice device,
                                  VkDescriptorSetLayout descriptorSetLayout,
                                  const struct VkAllocationCallbacks *pAllocator);

/**
 * Create descriptor pool
 */
VkResult vkCreateDescriptorPool(VkDevice device,
                                const struct VkDescriptorPoolCreateInfo *pCreateInfo,
                                const struct VkAllocationCallbacks *pAllocator,
                                VkDescriptorPool *pDescriptorPool);

/**
 * Destroy descriptor pool
 */
void vkDestroyDescriptorPool(VkDevice device,
                             VkDescriptorPool descriptorPool,
                             const struct VkAllocationCallbacks *pAllocator);

/**
 * Reset descriptor pool
 */
VkResult vkResetDescriptorPool(VkDevice device,
                               VkDescriptorPool descriptorPool,
                               VkDescriptorPoolResetFlags flags);

/**
 * Allocate descriptor sets
 */
VkResult vkAllocateDescriptorSets(VkDevice device,
                                  const struct VkDescriptorSetAllocateInfo *pAllocateInfo,
                                  VkDescriptorSet *pDescriptorSets);

/**
 * Free descriptor sets
 */
VkResult vkFreeDescriptorSets(VkDevice device,
                              VkDescriptorPool descriptorPool,
                              uint32_t descriptorSetCount,
                              const VkDescriptorSet *pDescriptorSets);

/**
 * Update descriptor sets
 */
void vkUpdateDescriptorSets(VkDevice device,
                            uint32_t descriptorWriteCount,
                            const struct VkWriteDescriptorSet *pDescriptorWrites,
                            uint32_t descriptorCopyCount,
                            const struct VkCopyDescriptorSet *pDescriptorCopies);

/**
 * Create a fence
 */
VkResult vkCreateFence(VkDevice device,
                       const struct VkFenceCreateInfo *pCreateInfo,
                       const struct VkAllocationCallbacks *pAllocator,
                       VkFence *pFence);

/**
 * Destroy a fence
 */
void vkDestroyFence(VkDevice device, VkFence fence, const struct VkAllocationCallbacks *pAllocator);

/**
 * Reset fences
 */
VkResult vkResetFences(VkDevice device, uint32_t fenceCount, const VkFence *pFences);

/**
 * Get fence status
 */
VkResult vkGetFenceStatus(VkDevice device, VkFence fence);

/**
 * Wait for fences
 */
VkResult vkWaitForFences(VkDevice device,
                         uint32_t fenceCount,
                         const VkFence *pFences,
                         VkBool32 waitAll,
                         uint64_t timeout);

/**
 * Create a semaphore
 */
VkResult vkCreateSemaphore(VkDevice device,
                           const struct VkSemaphoreCreateInfo *pCreateInfo,
                           const struct VkAllocationCallbacks *pAllocator,
                           VkSemaphore *pSemaphore);

/**
 * Destroy a semaphore
 */
void vkDestroySemaphore(VkDevice device,
                        VkSemaphore semaphore,
                        const struct VkAllocationCallbacks *pAllocator);

/**
 * Create an event
 */
VkResult vkCreateEvent(VkDevice device,
                       const struct VkEventCreateInfo *pCreateInfo,
                       const struct VkAllocationCallbacks *pAllocator,
                       VkEvent *pEvent);

/**
 * Destroy an event
 */
void vkDestroyEvent(VkDevice device, VkEvent event, const struct VkAllocationCallbacks *pAllocator);

/**
 * Get event status
 */
VkResult vkGetEventStatus(VkDevice device, VkEvent event);

/**
 * Set event
 */
VkResult vkSetEvent(VkDevice device, VkEvent event);

/**
 * Reset event
 */
VkResult vkResetEvent(VkDevice device, VkEvent event);

#endif  /* KRONOS_COMPUTE_H */
